const jwt = require("jsonwebtoken"); //For generating DMS jwt
const axios = require('axios'); //For making requests

class DMSClientChannel {
	/**
	* Private class config variables
	*/
	#API_URL;
	#CHANNEL_ID;
	#JWT_SECRET;
	#LOGGING_ENABLED;

    constructor(config) {
        this.#API_URL = config.API_URL;
		this.#CHANNEL_ID = config.CHANNEL_ID;
		this.#JWT_SECRET = config.JWT_SECRET;
		this.#LOGGING_ENABLED = false; //set logging to false by default
    }

	/**
	* onTypingIndicator
   	* Returns the customer id recieved from the dms event
	* @public
	*/
	onTypingIndicator(customer_id) { }

	/**
	* onCsrEndSession
	* Returns the customer id recieved from the dms event
	* @public
	*/
	onCsrEndSession(customer_id) { }

	/**
	* onTextMessage
	* Returns the message object recieved from the dms
	* @public
	*/
	onTextMessage(message) { }
	
	/**
	* onMenuMessage
   	* Returns the message object recieved from the dms
	* @public
	*/
	onMenuMessage(message) { }

	/**
	* onCarouselMessage
   	* Returns the message object recieved from the dms
	* @public
	*/
	onCarouselMessage(message) { }
	
	/**
	* onUrlLinkMessage
    * Returns the message object recieved from the dms
	* @public
	*/
	onUrlLinkMessage(message) { }

	/**
	* logRequests
	* Sets the logging logging status
	* @public
	* @param status {Boolean}
	*/
	logRequests(status) {
		status ? this.#LOGGING_ENABLED = true : this.#LOGGING_ENABLED = false;		
	}

	/**
	* onRequest
	* @public
	* @param req
    * @param callback
	*/
    onRequest(req, callback) {
		try {
			//Get the jwt from request
			let token = this.#getToken(req);

			//Check if jwt is valid
			let verified = this.#validateToken(token);

			//Console Logging
			if (this.#LOGGING_ENABLED) {
				let log_prefix = "onRequest - ";
				console.log(log_prefix + "Token", token);
				console.log(log_prefix + "verified", verified);
				console.log(log_prefix + "Message recieved from DMS:", req.body);
			}

			if (verified) {
				//Send a message to webex teams, microsoft teams, slack etc. 
				this.#runMessageCallbacks(req.body);

				//Return 200 ok  status
				callback(200, "success");
				return;
			} else {
				//Return 403 forbidden. invalid request signature
				callback(403, "forbidden");
				return;
			}

		} catch (err) {
			callback(401, err);
			return;
		}
	}


	/**
	* returns the request token from a DMS http request 
	* @private
	* @param req {Object} 
	*/
	#getToken(req) {
		if (req.headers.authorization && req.headers.authorization.split(' ')[0] === 'Bearer')
			return req.headers.authorization.split(' ')[1];
		return null;
	}

	/**
	* Verifies a DMS request token using class instance configs.
    * Returns the boolean represeting the DMS token verification outcome status
	* @private
	* @param req_token
	*/
	#validateToken(req_token) {
		//Return if there's no token
		if (!req_token) {
			console.log("No token in request");
			return false;
		}

		//Max age of token should be less than 5mins
		let options = {
			maxAge: 300, //300ms = 5mins
			algorithms: ['HS256']
		}

		try {
			//Verify token 
			const {
				iat,
				iss
			} = jwt.verify(req_token, this.#JWT_SECRET, options);

			

			//Console Logging
			if (this.#LOGGING_ENABLED) {
				let log_prefix = "validateToken - ";
				console.log(log_prefix + "iss: ", iss);
				console.log(log_prefix + "iat: ", iat);
				console.log(log_prefix + "channel id: ", this.#CHANNEL_ID);
			}

			if (iss === this.#CHANNEL_ID) {
				if (this.#LOGGING_ENABLED) {
					console.log("valid token - validateToken()");
				}
				return true;
			} else {
				if (this.#LOGGING_ENABLED) {
					console.log("invalid token - validateToken()");
				}
				return false;
			}

		} catch (err) {
			console.log("error - validateToken()", err);
			return false; //invalid token
		}

	}

	/**
	* @private
	* @param message
	*/
	#runMessageCallbacks (message) {
		let callback = null
		let callback_args = message; //set to message by default as it's used in most instances

		switch (message.type) {
			case "typing_indicator":
				callback = this.onTypingIndicator;
				callback_args = message.customer_id;
				break;
			case "csr_end_session":
				callback = this.onCsrEndSession;
				callback_args = message.customer_id;
				break;
			case "text":
				callback = this.onTextMessage;
				break;
			case "menu":
				callback = this.onMenuMessage;
				break;
			case "carousel":
				callback = this.onCarouselMessage;
				break;
			case "link_button":
				callback = this.onUrlLinkMessage
				break;

			default:
				return; // return if message type is not detected.

		}
		//Check if callback is a valid function and pass in args
		if (callback && typeof(callback) === "function") {
			callback(callback_args);
		}
	}

	/**
	* Calls the DMS message API
    * Sends a single text message to DMS
	* @public
	* @param customer_id {String}
    * @param message_id {String}
	* @param message_text {String}
    * @param customer_name {String}
	*/
	sendTextMessage = async (customer_id, message_id, message_text, customer_name, callback) => {

		let message = {
			"type": "text",
			"customer_id": customer_id,
			"customer_name": customer_name,
			"message_id": message_id,
			"text": [message_text]
		}

		//Forward the formatted message to Digital Messageing.
		try {
			//Set request headers
			let options = this.#generateRequestOptions();

			//Make outbound call to Pega
			let response = await axios.post(this.#API_URL, message, options);
			
			//Console Logging
			if (this.#LOGGING_ENABLED) {
				let log_prefix = "sendTextMessage - ";
				console.log(log_prefix + "Request Headers: ", options);
				console.log(log_prefix + "Request Message: ", message);
				console.log(log_prefix + "DMS messaging API response: ", response.status);
			}
			
			//Check if callback is a valid function and pass in args
			if (callback && typeof(callback) === "function") {
				callback(response);
			}

		} catch (err) {
			console.log(err);
		}
	}

	/**
	* Calls the DMS message API
    * Sends a message to DMS
	* @public
	* @param message {Object} - should be a valid DMS messaging object
	*/
	sendMessage = async (message,callback) => {
		//Forward the formatted message to Digital Messageing.
		try {
			//Set request headers
			let options = this.#generateRequestOptions();

			//Make outbound call to Pega
			let response = await axios.post(this.#API_URL, message, options);

			//Console Logging
			if (this.#LOGGING_ENABLED) {
				let log_prefix = "sendMessage - ";
				console.log(log_prefix + "Request Headers: ", options);
				console.log(log_prefix + "Request Message: ", message);
				console.log(log_prefix + "DMS messaging API response: ", response.status);
			}
			//Check if callback is a valid function and pass in args
			if (callback && typeof(callback) === "function") {
				callback(response);
			}

		} catch (err) {
			console.log(err);
		}
	}

	/**
	* Calls the DMS message API
    * Sends the typing indicator
	* @public
	* @param customer_id {String}
	*/
	sendTypingIndicator = async (customer_id,callback) => {
		try {
			let message = {
				"type": "typing_indicator",
				"customer_id": customer_id
			};

			let options = this.#generateRequestOptions();

			//Make outbound call to DMS/Pega
			let response = await axios.post(this.#API_URL, message, options);
			//Console Logging
			if (this.#LOGGING_ENABLED) {
				let log_prefix = "sendTypingIndicator - ";
				console.log(log_prefix + "Request Headers: ", options);
				console.log(log_prefix + "Request Message: ", message);
				console.log(log_prefix + "DMS messaging API response: ", response.status);
			}

			//Check if callback is a valid function and pass in args
			if (callback && typeof(callback) === "function") {
				callback(response);
			}
		} catch (err) {
			console.log(err);
		}
	} 

	/**
	* returns the DMS messaging API request header using DMS config set in class instance
	* @private
	*/
	#generateRequestOptions() {
		try {
			//Generate token for DMS API request
			var token = jwt.sign({
				iss: this.#CHANNEL_ID
			}, this.#JWT_SECRET, { algorithm: 'HS256'});

			const options = {
				headers: {
					'Content-Type': 'application/json',
					'authorization': 'Bearer ' + token,
					'connection_id': this.#CHANNEL_ID
				}
			};

			return options;
		} catch (err) {
			console.log(err);
		}
	}

}//END CLASS

module.exports = DMSClientChannel;